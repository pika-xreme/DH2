export const Scripts: ModdedBattleScriptsData = {
	inherit: 'gen2',
	gen: 2,
	init() {
		this.modData('Learnsets', 'abra').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'aerodactyl').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'alakazam').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'arbok').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'arcanine').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'articuno').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'beedrill').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'bellsprout').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'blastoise').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'bulbasaur').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'butterfree').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'chansey').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'charizard').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'charmander').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'charmeleon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'clefable').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'clefairy').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'cloyster').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'cubone').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'dewgong').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'diglett').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'dodrio').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'doduo').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'dragonair').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'dragonite').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'dratini').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'drowzee').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'dugtrio').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'eevee').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ekans').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'electabuzz').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'electrode').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'exeggcute').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'exeggutor').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'farfetchd').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'fearow').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'flareon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'gastly').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'gengar').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'geodude').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'gloom').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'golbat').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'goldeen').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'golduck').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'golem').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'graveler').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'grimer').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'growlithe').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'gyarados').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'haunter').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'hitmonchan').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'hitmonlee').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'horsea').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'hypno').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ivysaur').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'jigglypuff').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'jolteon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'jynx').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'kabuto').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'kabutops').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'kadabra').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'kangaskhan').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'kingler').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'koffing').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'krabby').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'lapras').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'lickitung').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'machamp').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'machoke').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'machop').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'magmar').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'magnemite').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'magneton').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'mankey').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'marowak').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'meowth').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'mew').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'mewtwo').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'moltres').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'mrmime').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'muk').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'nidoking').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'nidoqueen').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'nidoranf').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'nidoranm').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'nidorina').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'nidorino').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ninetales').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'oddish').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'omanyte').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'omastar').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'onix').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'paras').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'parasect').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'persian').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pidgeot').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pidgeotto').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pidgey').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pikachu').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pinsir').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'poliwag').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'poliwhirl').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'poliwrath').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ponyta').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'porygon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'primeape').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'psyduck').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'raichu').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'rapidash').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'raticate').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'rattata').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'rhydon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'rhyhorn').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'sandshrew').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'sandslash').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'scyther').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'seadra').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'seaking').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'seel').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'shellder').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'slowbro').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'slowpoke').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'snorlax').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'spearow').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'squirtle').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'starmie').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'staryu').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'tangela').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'tauros').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'tentacool').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'tentacruel').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'vaporeon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'venomoth').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'venonat').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'venusaur').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'victreebel').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'vileplume').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'voltorb').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'vulpix').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'wartortle').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'weepinbell').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'weezing').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'wigglytuff').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'zapdos').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'zubat').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'aipom').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ampharos').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ariados').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'azumarill').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'bayleef').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'bellossom').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'blissey').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'celebi').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'chikorita').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'chinchou').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'cleffa').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'corsola').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'crobat').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'croconaw').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'cyndaquil').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'delibird').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'donphan').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'dunsparce').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'elekid').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'entei').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'espeon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'feraligatr').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'flaaffy').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'forretress').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'furret').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'girafarig').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'gligar').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'granbull').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'heracross').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'hitmontop').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'hooh').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'hoothoot').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'hoppip').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'houndoom').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'houndour').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'igglybuff').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'jumpluff').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'kingdra').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'lanturn').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'larvitar').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ledian').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ledyba').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'lugia').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'magby').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'magcargo').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'mantine').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'mareep').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'marill').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'meganium').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'miltank').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'misdreavus').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'murkrow').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'natu').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'noctowl').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'octillery').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'phanpy').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pichu').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'piloswine').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pineco').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'politoed').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'porygon2').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'pupitar').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'quagsire').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'quilava').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'qwilfish').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'raikou').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'remoraid').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'scizor').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'sentret').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'shuckle').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'skarmory').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'skiploom').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'slowking').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'slugma').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'smeargle').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'smoochum').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'sneasel').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'snubbull').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'spinarak').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'stantler').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'steelix').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'sudowoodo').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'suicune').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'sunflora').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'sunkern').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'swinub').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'teddiursa').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'togepi').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'togetic').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'totodile').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'typhlosion').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'tyranitar').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'tyrogue').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'umbreon').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'ursaring').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'wobbuffet').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'wooper').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'xatu').learnset.terablast = ["2M"];
		this.modData('Learnsets', 'yanma').learnset.terablast = ["2M"];
	},
	side: {
		inherit: true,
		chooseMove(
			moveText?: string | number,
			targetLoc = 0,
			event: 'mega' | 'zmove' | 'ultra' | 'dynamax' | 'terastallize' | '' = ''
		) {
			if (this.requestState !== 'move') {
				return this.emitChoiceError(`Can't move: You need a ${this.requestState} response`);
			}
			const index = this.getChoiceIndex();
			if (index >= this.active.length) {
				return this.emitChoiceError(`Can't move: You sent more choices than unfainted Pokémon.`);
			}
			const autoChoose = !moveText;
			const pokemon: Pokemon = this.active[index];
	
			// Parse moveText (name or index)
			// If the move is not found, the action is invalid without requiring further inspection.
	
			const request = pokemon.getMoveRequestData();
			let moveid = '';
			let targetType = '';
			if (autoChoose) moveText = 1;
			if (typeof moveText === 'number' || (moveText && /^[0-9]+$/.test(moveText))) {
				// Parse a one-based move index.
				const moveIndex = Number(moveText) - 1;
				if (moveIndex < 0 || moveIndex >= request.moves.length || !request.moves[moveIndex]) {
					return this.emitChoiceError(`Can't move: Your ${pokemon.name} doesn't have a move ${moveIndex + 1}`);
				}
				moveid = request.moves[moveIndex].id;
				targetType = request.moves[moveIndex].target!;
			} else {
				// Parse a move ID.
				// Move names are also allowed, but may cause ambiguity (see client issue #167).
				moveid = toID(moveText);
				if (moveid.startsWith('hiddenpower')) {
					moveid = 'hiddenpower';
				}
				for (const move of request.moves) {
					if (move.id !== moveid) continue;
					targetType = move.target || 'normal';
					break;
				}
				if (!targetType && ['', 'dynamax'].includes(event) && request.maxMoves) {
					for (const [i, moveRequest] of request.maxMoves.maxMoves.entries()) {
						if (moveid === moveRequest.move) {
							moveid = request.moves[i].id;
							targetType = moveRequest.target;
							event = 'dynamax';
							break;
						}
					}
				}
				if (!targetType && ['', 'zmove'].includes(event) && request.canZMove) {
					for (const [i, moveRequest] of request.canZMove.entries()) {
						if (!moveRequest) continue;
						if (moveid === toID(moveRequest.move)) {
							moveid = request.moves[i].id;
							targetType = moveRequest.target;
							event = 'zmove';
							break;
						}
					}
				}
				if (!targetType) {
					return this.emitChoiceError(`Can't move: Your ${pokemon.name} doesn't have a move matching ${moveid}`);
				}
			}
	
			const moves = pokemon.getMoves();
			if (autoChoose) {
				for (const [i, move] of request.moves.entries()) {
					if (move.disabled) continue;
					if (i < moves.length && move.id === moves[i].id && moves[i].disabled) continue;
					moveid = move.id;
					targetType = move.target!;
					break;
				}
			}
			const move = this.battle.dex.moves.get(moveid);
	
			// Z-move
	
			const zMove = event === 'zmove' ? this.battle.actions.getZMove(move, pokemon) : undefined;
			if (event === 'zmove' && !zMove) {
				return this.emitChoiceError(`Can't move: ${pokemon.name} can't use ${move.name} as a Z-move`);
			}
			if (zMove && this.choice.zMove) {
				return this.emitChoiceError(`Can't move: You can't Z-move more than once per battle`);
			}
	
			if (zMove) targetType = this.battle.dex.moves.get(zMove).target;
	
			// Dynamax
			// Is dynamaxed or will dynamax this turn.
			const maxMove = (event === 'dynamax' || pokemon.volatiles['dynamax']) ?
				this.battle.actions.getMaxMove(move, pokemon) : undefined;
			if (event === 'dynamax' && !maxMove) {
				return this.emitChoiceError(`Can't move: ${pokemon.name} can't use ${move.name} as a Max Move`);
			}
	
			if (maxMove) targetType = this.battle.dex.moves.get(maxMove).target;
	
			// Validate targetting
	
			if (autoChoose) {
				targetLoc = 0;
			} else if (this.battle.actions.targetTypeChoices(targetType)) {
				if (!targetLoc && this.active.length >= 2) {
					return this.emitChoiceError(`Can't move: ${move.name} needs a target`);
				}
				if (!this.battle.validTargetLoc(targetLoc, pokemon, targetType)) {
					return this.emitChoiceError(`Can't move: Invalid target for ${move.name}`);
				}
			} else {
				if (targetLoc) {
					return this.emitChoiceError(`Can't move: You can't choose a target for ${move.name}`);
				}
			}
	
			const lockedMove = pokemon.getLockedMove();
			if (lockedMove) {
				let lockedMoveTargetLoc = pokemon.lastMoveTargetLoc || 0;
				const lockedMoveID = toID(lockedMove);
				if (pokemon.volatiles[lockedMoveID] && pokemon.volatiles[lockedMoveID].targetLoc) {
					lockedMoveTargetLoc = pokemon.volatiles[lockedMoveID].targetLoc;
				}
				this.choice.actions.push({
					choice: 'move',
					pokemon,
					targetLoc: lockedMoveTargetLoc,
					moveid: lockedMoveID,
				});
				return true;
			} else if (!moves.length && !zMove) {
				// Override action and use Struggle if there are no enabled moves with PP
				// Gen 4 and earlier announce a Pokemon has no moves left before the turn begins, and only to that player's side.
				if (this.battle.gen <= 4) this.send('-activate', pokemon, 'move: Struggle');
				moveid = 'struggle';
			} else if (maxMove) {
				// Dynamaxed; only Taunt and Assault Vest disable Max Guard, but the base move must have PP remaining
				if (pokemon.maxMoveDisabled(move)) {
					return this.emitChoiceError(`Can't move: ${pokemon.name}'s ${maxMove.name} is disabled`);
				}
			} else if (!zMove) {
				// Check for disabled moves
				let isEnabled = false;
				let disabledSource = '';
				for (const m of moves) {
					if (m.id !== moveid) continue;
					if (!m.disabled) {
						isEnabled = true;
						break;
					} else if (m.disabledSource) {
						disabledSource = m.disabledSource;
					}
				}
				if (!isEnabled) {
					// Request a different choice
					if (autoChoose) throw new Error(`autoChoose chose a disabled move`);
					const includeRequest = this.updateRequestForPokemon(pokemon, req => {
						let updated = false;
						for (const m of req.moves) {
							if (m.id === moveid) {
								if (!m.disabled) {
									m.disabled = true;
									updated = true;
								}
								if (m.disabledSource !== disabledSource) {
									m.disabledSource = disabledSource;
									updated = true;
								}
								break;
							}
						}
						return updated;
					});
					const status = this.emitChoiceError(`Can't move: ${pokemon.name}'s ${move.name} is disabled`, includeRequest);
					if (includeRequest) this.emitRequest(this.activeRequest!);
					return status;
				}
				// The chosen move is valid yay
			}
	
			// Mega evolution
	
			const mega = (event === 'mega');
			if (mega && !pokemon.canMegaEvo) {
				return this.emitChoiceError(`Can't move: ${pokemon.name} can't mega evolve`);
			}
			if (mega && this.choice.mega) {
				return this.emitChoiceError(`Can't move: You can only mega-evolve once per battle`);
			}
			const ultra = (event === 'ultra');
			if (ultra && !pokemon.canUltraBurst) {
				return this.emitChoiceError(`Can't move: ${pokemon.name} can't ultra burst`);
			}
			if (ultra && this.choice.ultra) {
				return this.emitChoiceError(`Can't move: You can only ultra burst once per battle`);
			}
			let dynamax = (event === 'dynamax');
			const canDynamax = this.activeRequest?.active[this.active.indexOf(pokemon)].canDynamax;
			if (dynamax && (this.choice.dynamax || !canDynamax)) {
				if (pokemon.volatiles['dynamax']) {
					dynamax = false;
				} else {
					if (this.battle.gen !== 8) {
						return this.emitChoiceError(`Can't move: Dynamaxing doesn't outside of Gen 8.`);
					} else if (pokemon.side.canDynamaxNow()) {
						return this.emitChoiceError(`Can't move: ${pokemon.name} can't Dynamax now.`);
					} else if (pokemon.side.allySide?.canDynamaxNow()) {
						return this.emitChoiceError(`Can't move: It's your partner's turn to Dynamax.`);
					}
					return this.emitChoiceError(`Can't move: You can only Dynamax once per battle.`);
				}
			}
			const terastallize = (event === 'terastallize');
			if (terastallize && !pokemon.canTerastallize) {
				// Make this work properly
				return this.emitChoiceError(`Can't move: ${pokemon.name} can't Terastallize.`);
			}
			if (terastallize && this.choice.terastallize) {
				return this.emitChoiceError(`Can't move: You can only Terastallize once per battle.`);
			}
			if (terastallize && this.battle.gen !== 2) {
				// Make this work properly
				return this.emitChoiceError(`Can't move: You can only Terastallize in Gen 2.`);
			}
	
			this.choice.actions.push({
				choice: 'move',
				pokemon,
				targetLoc,
				moveid,
				mega: mega || ultra,
				zmove: zMove,
				maxMove: maxMove ? maxMove.id : undefined,
				terastallize: terastallize ? pokemon.teraType : undefined,
			});
	
			if (pokemon.maybeDisabled) {
				this.choice.cantUndo = this.choice.cantUndo || pokemon.isLastActive();
			}
	
			if (mega) this.choice.mega = true;
			if (ultra) this.choice.ultra = true;
			if (zMove) this.choice.zMove = true;
			if (dynamax) this.choice.dynamax = true;
			if (terastallize) this.choice.terastallize = true;
	
			return true;
		},
	},
	actions: {
		inherit: true,
		getDamage(source, target, move, suppressMessages) {
			// First of all, we get the move.
			if (typeof move === 'string') {
				move = this.dex.getActiveMove(move);
			} else if (typeof move === 'number') {
				move = {
					basePower: move,
					type: '???',
					category: 'Physical',
					willCrit: false,
					flags: {},
				} as unknown as ActiveMove;
			}

			// Let's test for immunities.
			if (!move.ignoreImmunity || (move.ignoreImmunity !== true && !move.ignoreImmunity[move.type])) {
				if (!target.runImmunity(move.type, true)) {
					return false;
				}
			}

			// Is it an OHKO move?
			if (move.ohko) {
				return target.maxhp;
			}

			// We edit the damage through move's damage callback
			if (move.damageCallback) {
				return move.damageCallback.call(this.battle, source, target);
			}

			// We take damage from damage=level moves
			if (move.damage === 'level') {
				return source.level;
			}

			// If there's a fix move damage, we run it
			if (move.damage) {
				return move.damage;
			}

			// We check the category and typing to calculate later on the damage
			move.category = this.battle.getCategory(move);
			// '???' is typeless damage: used for Struggle and Confusion etc
			if (!move.type) move.type = '???';
			const type = move.type;

			// We get the base power and apply basePowerCallback if necessary
			let basePower: number | false | null | undefined = move.basePower;
			if (move.basePowerCallback) {
				basePower = move.basePowerCallback.call(this.battle, source, target, move);
			}

			// We check for Base Power
			if (!basePower) {
				if (basePower === 0) return; // Returning undefined means not dealing damage
				return basePower;
			}
			basePower = this.battle.clampIntRange(basePower, 1);

			// Checking for the move's Critical Hit ratio
			let critRatio = this.battle.runEvent('ModifyCritRatio', source, target, move, move.critRatio || 0);
			critRatio = this.battle.clampIntRange(critRatio, 0, 5);
			const critMult = [0, 17, 32, 64, 85, 128];
			let isCrit = move.willCrit || false;
			if (typeof move.willCrit === 'undefined') {
				if (critRatio) {
					isCrit = this.battle.random(256) < critMult[critRatio];
				}
			}

			if (isCrit && this.battle.runEvent('CriticalHit', target, null, move)) {
				target.getMoveHitData(move).crit = true;
			}

			// Happens after crit calculation
			if (basePower) {
				// confusion damage
				if (move.isConfusionSelfHit) {
					move.type = move.baseMoveType!;
					basePower = this.battle.runEvent('BasePower', source, target, move, basePower, true);
					move.type = '???';
				} else {
					basePower = this.battle.runEvent('BasePower', source, target, move, basePower, true);
				}
				if (basePower && move.basePowerModifier) {
					basePower *= move.basePowerModifier;
				}
    		if (basePower < 60 && source.getTypes(true).includes(move.type) && source.terastallized && move.priority <= 0 &&
  			    !move.multihit && !((move.basePower === 0 || move.basePower === 150) && move.basePowerCallback)) {
  			  basePower = 60;
  		  }
			}
			if (!basePower) return 0;
			basePower = this.battle.clampIntRange(basePower, 1);

			// We now check for attacker and defender
			let level = source.level;

			// Using Beat Up
			if (move.allies) {
				this.battle.add('-activate', source, 'move: Beat Up', '[of] ' + move.allies[0].name);
				level = move.allies[0].level;
			}

			const attacker = move.overrideOffensivePokemon === 'target' ? target : source;
			const defender = move.overrideDefensivePokemon === 'source' ? source : target;

			const isPhysical = move.category === 'Physical';
			const atkType: StatIDExceptHP = move.overrideOffensiveStat || (isPhysical ? 'atk' : 'spa');
			const defType: StatIDExceptHP = move.overrideDefensiveStat || (isPhysical ? 'def' : 'spd');

			let unboosted = false;
			let noburndrop = false;

			if (isCrit) {
				if (!suppressMessages) this.battle.add('-crit', target);
				// Stat level modifications are ignored if they are neutral to or favour the defender.
				// Reflect and Light Screen defensive boosts are only ignored if stat level modifications were also ignored as a result of that.
				if (attacker.boosts[atkType] <= defender.boosts[defType]) {
					unboosted = true;
					noburndrop = true;
				}
			}

			let attack = attacker.getStat(atkType, unboosted, noburndrop);
			let defense = defender.getStat(defType, unboosted);

			// Using Beat Up
			if (move.allies) {
				attack = move.allies[0].species.baseStats.atk;
				move.allies.shift();
				defense = defender.species.baseStats.def;
			}

			// Moves that ignore offense and defense respectively.
			if (move.ignoreOffensive) {
				this.battle.debug('Negating (sp)atk boost/penalty.');
				// The attack drop from the burn is only applied when attacker's attack level is higher than defender's defense level.
				attack = attacker.getStat(atkType, true, true);
			}

			if (move.ignoreDefensive) {
				this.battle.debug('Negating (sp)def boost/penalty.');
				defense = target.getStat(defType, true, true);
			}

			if (move.id === 'present') {
				const typeIndexes: {[k: string]: number} = {
					Normal: 0, Fighting: 1, Flying: 2, Poison: 3, Ground: 4, Rock: 5, Bug: 7, Ghost: 8, Steel: 9,
					Fire: 20, Water: 21, Grass: 22, Electric: 23, Psychic: 24, Ice: 25, Dragon: 26, Dark: 27,
				};
				attack = 10;

				const attackerLastType = attacker.getTypes().slice(-1)[0];
				const defenderLastType = defender.getTypes().slice(-1)[0];

				defense = typeIndexes[attackerLastType] || 1;
				level = typeIndexes[defenderLastType] || 1;
				this.battle.hint("Gen 2 Present has a glitched damage calculation using the secondary types of the Pokemon for the Attacker's Level and Defender's Defense.", true);
			}

			// When either attack or defense are higher than 256, they are both divided by 4 and modded by 256.
			// This is what causes the rollover bugs.
			if (attack >= 256 || defense >= 256) {
				if (attack >= 1024 || defense >= 1024) {
					this.battle.hint("In Gen 2, a stat will roll over to a small number if it is larger than 1024.");
				}
				attack = this.battle.clampIntRange(Math.floor(attack / 4) % 256, 1);
				defense = this.battle.clampIntRange(Math.floor(defense / 4) % 256, 1);
			}

			// Self destruct moves halve defense at this point.
			if (move.selfdestruct && defType === 'def') {
				defense = this.battle.clampIntRange(Math.floor(defense / 2), 1);
			}

			// Let's go with the calculation now that we have what we need.
			// We do it step by step just like the game does.
			let damage = level * 2;
			damage = Math.floor(damage / 5);
			damage += 2;
			damage *= basePower;
			damage *= attack;
			damage = Math.floor(damage / defense);
			damage = Math.floor(damage / 50);
			if (isCrit) damage *= 2;
			damage = Math.floor(this.battle.runEvent('ModifyDamage', attacker, defender, move, damage));
			damage = this.battle.clampIntRange(damage, 1, 997);
			damage += 2;

			// Weather modifiers
			if (
				(type === 'Water' && this.battle.field.isWeather('raindance')) ||
				(type === 'Fire' && this.battle.field.isWeather('sunnyday'))
			) {
				damage = Math.floor(damage * 1.5);
			} else if (
				((type === 'Fire' || move.id === 'solarbeam') && this.battle.field.isWeather('raindance')) ||
				(type === 'Water' && this.battle.field.isWeather('sunnyday'))
			) {
				damage = Math.floor(damage / 2);
			}

			// STAB damage bonus, the "???" type never gets STAB
			if (type !== '???' && (source.getTypes(false, true).includes(type) || source.hasType(type))) {
				damage += Math.floor(damage / 2);
			}
      
			// Tera
			if (source.terastallized === 'Stellar') {
        if (!source.stellarBoostedTypes.includes(type)) {
			    if (type !== '???' && source.hasType(type)) {
					  damage *= 1.333;
          } else {
  					damage *= 1.2;
          }
					source.stellarBoostedTypes.push(type);
			  }
      } else {
				if (source.terastallized === type && source.getTypes(false, true).includes(type)) {
					damage *= 1.333;
				}
			}

			// Type effectiveness
			const totalTypeMod = target.runEffectiveness(move);
			// Super effective attack
			if (totalTypeMod > 0) {
				if (!suppressMessages) this.battle.add('-supereffective', target);
				damage *= 2;
				if (totalTypeMod >= 2) {
					damage *= 2;
				}
			}
			// Resisted attack
			if (totalTypeMod < 0) {
				if (!suppressMessages) this.battle.add('-resisted', target);
				damage = Math.floor(damage / 2);
				if (totalTypeMod <= -2) {
					damage = Math.floor(damage / 2);
				}
			}

			// Apply random factor if damage is greater than 1, except for Flail and Reversal
			if (!move.noDamageVariance && damage > 1) {
				damage *= this.battle.random(217, 256);
				damage = Math.floor(damage / 255);
			}

			// If damage is less than 1, we return 1
			if (basePower && !Math.floor(damage)) {
				return 1;
			}

			// We are done, this is the final damage
			return damage;
		},
  	canTerastallize(pokemon: Pokemon) {
  		if (pokemon.getItem().zMove || pokemon.canMegaEvo || this.dex.gen !== 2) {
  			return null;
  		}
  		return pokemon.teraType;
  	},
  	terastallize(pokemon: Pokemon) {
  		if (pokemon.illusion && ['Ogerpon', 'Terapagos'].includes(pokemon.illusion.species.baseSpecies)) {
  			this.battle.singleEvent('End', this.dex.abilities.get('Illusion'), pokemon.abilityState, pokemon);
  		}
  		const type = pokemon.teraType;
  		this.battle.add('-terastallize', pokemon, type);
  		pokemon.terastallized = type;
  		for (const ally of pokemon.side.pokemon) {
  			ally.canTerastallize = null;
  		}
  		pokemon.addedType = '';
  		pokemon.knownType = true;
  		pokemon.apparentType = type;
  		if (pokemon.species.baseSpecies === 'Ogerpon') {
  			const tera = pokemon.species.id === 'ogerpon' ? 'tealtera' : 'tera';
  			pokemon.formeChange(pokemon.species.id + tera, null, true);
  		}
  		if (pokemon.species.name === 'Terapagos-Terastal' && type === 'Stellar') {
  			pokemon.formeChange('Terapagos-Stellar', null, true);
  			pokemon.baseMaxhp = Math.floor(Math.floor(
  				2 * pokemon.species.baseStats['hp'] + pokemon.set.ivs['hp'] + Math.floor(pokemon.set.evs['hp'] / 4) + 100
  			) * pokemon.level / 100 + 10);
  			const newMaxHP = pokemon.baseMaxhp;
  			pokemon.hp = newMaxHP - (pokemon.maxhp - pokemon.hp);
  			pokemon.maxhp = newMaxHP;
  			this.battle.add('-heal', pokemon, pokemon.getHealth, '[silent]');
  		}
  		this.battle.runEvent('AfterTerastallization', pokemon);
  	},
  },
};
